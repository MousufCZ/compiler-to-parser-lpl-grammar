package lpl.compiler;
import lpl.ast.*;
import static lpl.compiler.FreshLabelGenerator.freshLab;
import static lpl.compiler.IRUtils.*;
import java.util.ArrayList;
import java.util.List;
import ir.ast.*;
import lpl.ast.util.VisitorAdapter;

public class Compiler extends VisitorAdapter<IRExp> {

    /**
     * The IR instruction sequence generated by the compiler so far.
     */
    private final List<IRStm> emitted;
    private List<Formal> param;
    private List<VarDecl> var;
    String label = "";

    /**
     * Initialise a new compiler.
     */
    public Compiler() {
        emitted = new ArrayList<>();
    }


    /**
     * Add a new IR statement to the list of emitted instructions.
     *
     * @param s the IR statement to emit
     */
    private void emit(IRStm s) {
        emitted.add(s);
    }


    /**
     * Compile an LPL program into an IR program.
     * @param p the LPL program
     * @return the IR program
     */
    public IRProgram compile(Program p) {
        emitted.clear();
        // Prototype: here we assume there is just one function definition
        // (the "main" function) and that it expects no parameters, so we just
        // compile the body of the main function.
        // A complete solution will instead emit a CALL to the main function
        // (with actual parameter values retrieved from the stack), then
        // a JUMP to _END, followed by the compiled versions of all the
        // function definitions (including the main function).

        List<IRExp> ire = new ArrayList<>();
        for (int i = 0; i < p.main.fs.size(); i++){
            ire.add(MEM(BINOP(TEMP("FP"), IROp.ADD, CONST((i*-1) - 1))));
        }

        emit(EXP(CALL(NAME(p.main.id), ire)));
        emit(JUMP(NAME("_END")));

        p.main.accept(this);

        for (FunDef f: p.fds)
            f.accept(this);

        IRProgram irp = new IRProgram(emitted);
        return irp;
    }


    /**
     * Ofset - Stack
     * @param id
     * @return the stack location
     */
    public int offset(String id){

        if (var != null && !var.isEmpty()) {
            for (VarDecl f : var) {
                if (f.id.equals(id)){
                    int n = var.indexOf(f) * -1;
                    return n - 1;
                }
            }
        }
        if (param != null && !param.isEmpty()) {
            for (Formal v : param) {
                if (v.id.equals(id)) {
                    return param.indexOf(v) + 2;
                }
            }
        }
        return 0;
    }


    /**
     * IRExp - FunDef
     * @param n
     * @return null
     */
    @Override
    public IRExp visit(FunDef n) {
        param = n.fs;
        var = n.lvs;
        emit(LABEL(n.id));
        emit(PROLOGUE(n.fs.size(), n.lvs.size()));
        for (Stm s: n.ss)
            s.accept(this);
        label = freshLab();
        emit(LABEL(label));
        emit(EPILOGUE(n.fs.size(), n.lvs.size()));
        return null;
    }


    /**
     * IRExp - StmAssign
     * @param s
     * @return null
     */
    @Override
    public IRExp visit(StmAssign s) {
        IRExp ire = s.e.accept(this);
        emit(MOVE(MEM(BINOP(TEMP("FP"), IROp.ADD, CONST(offset(s.id)))), ire));
        return null;
    }


    /**
     * IRExp - PrimaryExpNot
     * @param e
     * @return IRE bool
     */
    @Override
    public IRExp visit(PrimaryExpNot e) {
        IRExp ire = e.e.accept(this);
        return BINOP(ire, IROp.EQ, CONST(0));
    }


    /**
     * IRExp - StmBlock
     * @param stm
     * @return null
     */
    @Override
    public IRExp visit(StmBlock stm) {
        for (Stm s : stm.ss) {
            s.accept(this);
        }
        return null;
    }


    /**
     * IRExp - StmWhile
     * @param n
     * @return null
     */
    @Override
    public IRExp visit(StmWhile n) {
        IRExp ire = n.e.accept(this);
        String s1 = freshLab();
        String s2 = freshLab();
        String startLab = freshLab();
        emit(LABEL(startLab));
        emit(CJUMP(ire, IROp.EQ, CONST(1), s1, s2));
        emit(LABEL(s1));
        n.body.accept(this);
        emit(JUMP(NAME(startLab)));
        emit(LABEL(s2));
        return null;
    }


    /**
     * IRExp - StmOutput
     * @param n
     * @return null
     */
    @Override
    public IRExp visit(StmOutput n) {
        IRExp ire = n.e.accept(this);
        emit(EXP((CALL(NAME("_printint"), ire))));
        return null;
    }


    /**
     * IRExp - StmOutChar
     * @param n
     * @return null
     */
    @Override
    public IRExp visit(StmOutchar n) {
        IRExp ire = n.e.accept(this);
        emit(EXP((CALL(NAME("_printchar"), ire))));
        return null;
    }


    /**
     * IRExp - StmIf
     * @param stm
     * @return null
     */
    public IRExp visit(StmIf stm) {
        IRExp ire1 = stm.e.accept(this);
        String s1 = freshLab();
        String s2 = freshLab();
        String endLab = freshLab();
        emit(CJUMP(ire1, IROp.EQ, CONST(1), s1, s2));
        emit(LABEL(s1));
        stm.st.accept(this);
        emit(JUMP(NAME(endLab)));
        emit(LABEL(s2));
        stm.sf.accept(this);
        emit(LABEL(endLab));
        return null;
    }


    /**
     * IRExp - StmReturn
     * @param n
     * @return null
     */
    @Override
    public IRExp visit(StmReturn n) {
        IRExp ire = n.e.accept(this);
        emit(MOVE(TEMP("RV"), ire));
        emit(JUMP(NAME(label)));
        return null;
    }


    /**
     * IRExp - PrimaryExpInteger
     * @param n
     * @return const n.i
     */
    @Override
    public IRExp visit(PrimaryExpInteger n) {
        return CONST(n.i);
    }


    /**
     * IRExp - ExpPrimaryExp
     * @param e
     * @return program compile accept
     */
    @Override
    public IRExp visit(ExpPrimaryExp e) {
        // an ExpPrimaryExp is just a PrimaryExp wrapped up as an Exp,
        // so we just compile the PrimaryExp that it contains
        return e.e.accept(this);
    }


    /**
     * IRExp - PrimaryExpTrue
     * @param e
     * @return true
     */
    @Override
    public IRExp visit(PrimaryExpTrue e) {
        return CONST(1);
    }


    /**
     * IRExp - PrimaryExpFalse
     * @param e
     * @return false
     */
    @Override
    public IRExp visit(PrimaryExpFalse e) {
        return CONST(0);
    }


    /**
     * IRExp - Program
     * @param n
     * @return visit n
     */
    @Override
    public IRExp visit(Program n) {
        return super.visit(n);
    }


    /**
     * IRExp - ExpOp
     * @param n
     * @return BinOp required
     */
    @Override
    public IRExp visit(ExpOp n) {
        IRExp ire1 = n.e1.accept(this);
        IRExp ire2 = n.e2.accept(this);
        if (n.op.toString().equals("+") || n.op.toString().equals("||"))
            return BINOP(ire1, IROp.ADD, ire2);
        else if (n.op.toString().equals("-"))
            return BINOP(ire1, IROp.SUB, ire2);
        else if (n.op.toString().equals("/"))
            return BINOP(ire1, IROp.DIV, ire2);
        else if (n.op.toString().equals("*") || n.op.toString().equals("&&"))
            return BINOP(ire1, IROp.MUL, ire2);
        else if (n.op.toString().equals("<"))
            return BINOP(ire1, IROp.LT, ire2);
        else if (n.op.toString().equals("=="))
            return BINOP(ire1, IROp.EQ, ire2);
        else return super.visit(n);
    }


    /**
     * IRExp - PrimaryExpVar
     * @param n
     * @return MEM of Binop at address TEMP
     */
    @Override
    public IRExp visit(PrimaryExpVar n) {
        return MEM(BINOP(TEMP("FP"), IROp.ADD, CONST(offset(n.id))));
    }


    /**
     * IRExp - ExpCall
     * @param n
     * @return Evaluation of an address
     */
    @Override
    public IRExp visit(ExpCall n) {
        List<IRExp> ire = new ArrayList<>();
        for (Exp e: n.es)
            ire.add(e.accept(this));
        return CALL(NAME(n.id), ire);
    }


    /**
     * IRExp - StmCall
     * @param n
     * @return null
     */
    @Override
    public IRExp visit(StmCall n) {
        List<IRExp> ire = new ArrayList<>();
        for (Exp e: n.es)
            ire.add(e.accept(this));
        emit(EXP(CALL(NAME(n.id), ire)));
        return null;
    }


    /**
     * IRExp - PrimaryExpExp
     * @param n
     * @return project complile accept
     */
    @Override
    public IRExp visit(PrimaryExpExp n) {
        return n.e.accept(this);
    }


    /**
     * IRExp - PrimaryExpNewArray
     * This method was not completed
     * @param n
     * @return N/A
     */
    @Override
    public IRExp visit(PrimaryExpNewArray n) {
        IRExp ire = n.e.accept(this);
        String s1 = freshLab();

        ESEQ(SEQ(MOVE(TEMP(s1), CALL(NAME(" _malloc"), ire)),
              MOVE(MEM(TEMP(s1)), CONST(1))), TEMP(s1));
        return null;
    }
}
